<?xml version="1.0"?>


<!DOCTYPE rdf:RDF [
    <!ENTITY owl "http://www.w3.org/2002/07/owl#" >
    <!ENTITY xsd "http://www.w3.org/2001/XMLSchema#" >
    <!ENTITY owl2xml "http://www.w3.org/2006/12/owl2-xml#" >
    <!ENTITY rdfs "http://www.w3.org/2000/01/rdf-schema#" >
    <!ENTITY rdf "http://www.w3.org/1999/02/22-rdf-syntax-ns#" >
    <!ENTITY java "http://evolizer.org/ontologies/seon/2009/06/java.owl#" >
]>


<rdf:RDF xmlns="http://evolizer.org/ontologies/seon/2009/06/java.owl#"
     xml:base="http://evolizer.org/ontologies/seon/2009/06/java.owl"
     xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
     xmlns:owl2xml="http://www.w3.org/2006/12/owl2-xml#"
     xmlns:owl="http://www.w3.org/2002/07/owl#"
     xmlns:xsd="http://www.w3.org/2001/XMLSchema#"
     xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
     xmlns:java="http://evolizer.org/ontologies/seon/2009/06/java.owl#">
    <owl:Ontology rdf:about="">
        <rdfs:comment
            >This ontology models Java entities.</rdfs:comment>
    </owl:Ontology>
    


    <!-- 
    ///////////////////////////////////////////////////////////////////////////////////////
    //
    // Annotation properties
    //
    ///////////////////////////////////////////////////////////////////////////////////////
     -->

    <owl:AnnotationProperty rdf:about="#todo"/>
    


    <!-- 
    ///////////////////////////////////////////////////////////////////////////////////////
    //
    // Object Properties
    //
    ///////////////////////////////////////////////////////////////////////////////////////
     -->

    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#accessesField -->

    <owl:ObjectProperty rdf:about="#accessesField">
        <rdfs:comment
            >Fields can be accessed (i.e., its value can be read and/or set) from within a method or constructor. The inverse property is isAccessedByMethod.

Special cases, such as (static) initializers are not handled so far.</rdfs:comment>
        <rdfs:range rdf:resource="#Field"/>
        <owl:inverseOf rdf:resource="#isAccessedByMethod"/>
        <rdfs:domain>
            <owl:Class>
                <owl:unionOf rdf:parseType="Collection">
                    <rdf:Description rdf:about="#Constructor"/>
                    <rdf:Description rdf:about="#Method"/>
                </owl:unionOf>
            </owl:Class>
        </rdfs:domain>
    </owl:ObjectProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#declaresConstructor -->

    <owl:ObjectProperty rdf:about="#declaresConstructor">
        <rdf:type rdf:resource="&owl;InverseFunctionalProperty"/>
        <rdfs:comment
            >A class can declare one or several constructors. If a class does not explicitely declare one then Java will add an empty default constructor. The inverse property is isDeclaredConstructorOf.</rdfs:comment>
        <rdfs:range rdf:resource="#Constructor"/>
        <owl:inverseOf rdf:resource="#isDeclaredConstructorOf"/>
        <rdfs:domain>
            <owl:Class>
                <owl:unionOf rdf:parseType="Collection">
                    <rdf:Description rdf:about="#Class"/>
                    <rdf:Description rdf:about="#EnumerationType"/>
                </owl:unionOf>
            </owl:Class>
        </rdfs:domain>
    </owl:ObjectProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#declaresField -->

    <owl:ObjectProperty rdf:about="#declaresField">
        <rdf:type rdf:resource="&owl;InverseFunctionalProperty"/>
        <rdfs:comment
            >A class or interface can declare zero, one, or several fields.

If an interface declares a field then the field has to be final, i.e., a constant.

Note that a class inherits all fields from its superclass(es). This property is only applicable to fields that are explicitely declared in the given class.</rdfs:comment>
        <rdfs:domain rdf:resource="#ComplexType"/>
        <rdfs:range rdf:resource="#Field"/>
        <owl:inverseOf rdf:resource="#isDeclaredFieldOf"/>
    </owl:ObjectProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#declaresInnerComplexType -->

    <owl:ObjectProperty rdf:about="#declaresInnerComplexType">
        <rdfs:comment
            >Classes and Interfaces can declare inner annotation-, enumeration-, class-, and interface types, for example if they are mainly/only used internally.

If an interface declares an inner type then the type has to be &#39;final&#39;.</rdfs:comment>
        <rdfs:domain rdf:resource="#ComplexType"/>
        <rdfs:range rdf:resource="#ComplexType"/>
        <owl:inverseOf rdf:resource="#isDeclaredInnerComplexTypeOf"/>
    </owl:ObjectProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#declaresMethod -->

    <owl:ObjectProperty rdf:about="#declaresMethod">
        <rdf:type rdf:resource="&owl;InverseFunctionalProperty"/>
        <rdfs:comment
            >A class or interface can declare zero, one, or several methods.

If an interface declares a method then the method has to be abstract, i.e., it cannot have a body.

Note that a class can inherited additional methods from its superclass(es). This property is only applicable to method that are explicitely declared in the given class.

The inverse property is isDeclaredMethodOf.</rdfs:comment>
        <rdfs:domain rdf:resource="#ComplexType"/>
        <rdfs:range rdf:resource="#Method"/>
        <owl:inverseOf rdf:resource="#isDeclaredMethodOf"/>
    </owl:ObjectProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#hasAccessModifier -->

    <owl:ObjectProperty rdf:about="#hasAccessModifier">
        <rdf:type rdf:resource="&owl;FunctionalProperty"/>
        <rdfs:comment
            >AccessModifiers can be added to Constructors, ComplexTypes, Methods, and Fields.</rdfs:comment>
        <rdfs:range rdf:resource="#AccessModifier"/>
        <rdfs:domain>
            <owl:Class>
                <owl:unionOf rdf:parseType="Collection">
                    <rdf:Description rdf:about="#ComplexType"/>
                    <rdf:Description rdf:about="#Constructor"/>
                    <rdf:Description rdf:about="#Field"/>
                    <rdf:Description rdf:about="#Method"/>
                </owl:unionOf>
            </owl:Class>
        </rdfs:domain>
    </owl:ObjectProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#hasDatatype -->

    <owl:ObjectProperty rdf:about="#hasDatatype">
        <rdf:type rdf:resource="&owl;FunctionalProperty"/>
        <rdfs:comment
            >Since Java is a strongly type language, every variable needs to have a type (String, int, JFrame, etc.). The inverse property is isDatatypeOf.</rdfs:comment>
        <rdfs:range rdf:resource="#Datatype"/>
        <rdfs:domain rdf:resource="#Variable"/>
        <owl:inverseOf rdf:resource="#isDatatypeOf"/>
    </owl:ObjectProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#hasPackageMember -->

    <owl:ObjectProperty rdf:about="#hasPackageMember">
        <rdfs:comment
            >Packages contain members, i.e., ComplexTypes, such as Classes or Interfaces.</rdfs:comment>
        <rdfs:range rdf:resource="#ComplexType"/>
        <rdfs:domain rdf:resource="#Package"/>
        <owl:inverseOf rdf:resource="#isPackageMemberOf"/>
    </owl:ObjectProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#hasParameter -->

    <owl:ObjectProperty rdf:about="#hasParameter">
        <rdfs:comment
            >A method or constructor can have zero, one, or several parameters. The inverse property is isParameterOf.</rdfs:comment>
        <rdfs:range rdf:resource="#Parameter"/>
        <owl:inverseOf rdf:resource="#isParameterOf"/>
        <rdfs:domain>
            <owl:Class>
                <owl:unionOf rdf:parseType="Collection">
                    <rdf:Description rdf:about="#Constructor"/>
                    <rdf:Description rdf:about="#Method"/>
                </owl:unionOf>
            </owl:Class>
        </rdfs:domain>
    </owl:ObjectProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#hasReturnType -->

    <owl:ObjectProperty rdf:about="#hasReturnType">
        <rdf:type rdf:resource="&owl;FunctionalProperty"/>
        <todo
            >how should we treat &#39;void&#39;?</todo>
        <rdfs:comment
            >A method can return a value of a certain type or void (i.e., nothing). The inverse property is isReturnTypeOf.</rdfs:comment>
        <rdfs:range rdf:resource="#Datatype"/>
        <rdfs:domain rdf:resource="#Method"/>
        <owl:inverseOf rdf:resource="#isReturnTypeOf"/>
    </owl:ObjectProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#hasSubClass -->

    <owl:ObjectProperty rdf:about="#hasSubClass">
        <rdf:type rdf:resource="&owl;InverseFunctionalProperty"/>
        <rdfs:comment
            >This subproperty models the relationship between two different Class individuals by interconnecting the superordinate Class instance with the subordinate Class instance. The inverse property is called hasSuperClass.</rdfs:comment>
        <rdfs:range rdf:resource="#Class"/>
        <rdfs:domain rdf:resource="#Class"/>
        <rdfs:subPropertyOf rdf:resource="#hasSubType"/>
    </owl:ObjectProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#hasSubInterface -->

    <owl:ObjectProperty rdf:about="#hasSubInterface">
        <rdf:type rdf:resource="&owl;InverseFunctionalProperty"/>
        <rdfs:comment
            >This subproperty models the relationship between two distinct individu- 
als of the Interface class by connecting the superordinate Interface instance with the subordinate Interface instance. The inverse property is called hasSuperInterface.</rdfs:comment>
        <rdfs:range rdf:resource="#Interface"/>
        <rdfs:domain rdf:resource="#Interface"/>
        <rdfs:subPropertyOf rdf:resource="#hasSubType"/>
    </owl:ObjectProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#hasSubType -->

    <owl:ObjectProperty rdf:about="#hasSubType">
        <rdfs:comment
            >The hasSubType property is an abstract property that models subtyping in Java. Its inverse property is hasSuperType.</rdfs:comment>
        <rdfs:domain>
            <owl:Class>
                <owl:unionOf rdf:parseType="Collection">
                    <rdf:Description rdf:about="#Class"/>
                    <rdf:Description rdf:about="#Interface"/>
                </owl:unionOf>
            </owl:Class>
        </rdfs:domain>
        <rdfs:range>
            <owl:Class>
                <owl:unionOf rdf:parseType="Collection">
                    <rdf:Description rdf:about="#Class"/>
                    <rdf:Description rdf:about="#EnumerationType"/>
                    <rdf:Description rdf:about="#Interface"/>
                </owl:unionOf>
            </owl:Class>
        </rdfs:range>
    </owl:ObjectProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#hasSuperClass -->

    <owl:ObjectProperty rdf:about="#hasSuperClass">
        <rdf:type rdf:resource="&owl;FunctionalProperty"/>
        <rdfs:comment
            >A class can have one superclass, i.e., it can inherit from another class. The property is functional since Java does not support multiple inheritance. Its inverse property is hasSubClass.</rdfs:comment>
        <todo>transitive?</todo>
        <rdfs:domain rdf:resource="#Class"/>
        <rdfs:range rdf:resource="#Class"/>
        <owl:inverseOf rdf:resource="#hasSubClass"/>
        <rdfs:subPropertyOf rdf:resource="#hasSuperType"/>
    </owl:ObjectProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#hasSuperInterface -->

    <owl:ObjectProperty rdf:about="#hasSuperInterface">
        <rdf:type rdf:resource="&owl;FunctionalProperty"/>
        <todo>transitive?</todo>
        <rdfs:comment
            >An interface can extend another interface. The property is functional since Java does not support multiple inheritance. Its inverse property is hasSubInterface.</rdfs:comment>
        <rdfs:domain rdf:resource="#Interface"/>
        <rdfs:range rdf:resource="#Interface"/>
        <owl:inverseOf rdf:resource="#hasSubInterface"/>
        <rdfs:subPropertyOf rdf:resource="#hasSuperType"/>
    </owl:ObjectProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#hasSuperType -->

    <owl:ObjectProperty rdf:about="#hasSuperType">
        <rdfs:comment
            >Abstract property that models inheritance relationships in Java. Its inverse is &#39;hasSubType&#39;.</rdfs:comment>
        <owl:inverseOf rdf:resource="#hasSubType"/>
        <rdfs:range>
            <owl:Class>
                <owl:unionOf rdf:parseType="Collection">
                    <rdf:Description rdf:about="#Class"/>
                    <rdf:Description rdf:about="#Interface"/>
                </owl:unionOf>
            </owl:Class>
        </rdfs:range>
        <rdfs:domain>
            <owl:Class>
                <owl:unionOf rdf:parseType="Collection">
                    <rdf:Description rdf:about="#Class"/>
                    <rdf:Description rdf:about="#EnumerationType"/>
                    <rdf:Description rdf:about="#Interface"/>
                </owl:unionOf>
            </owl:Class>
        </rdfs:domain>
    </owl:ObjectProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#implementsInterface -->

    <owl:ObjectProperty rdf:about="#implementsInterface">
        <rdfs:comment
            >A class can implement zero, one, or several interfaces. It then needs to either provide an implementation for each of the interface methods, or be declared abstract. The inverse property is isImplementedBy.</rdfs:comment>
        <rdfs:domain rdf:resource="#Class"/>
        <rdfs:range rdf:resource="#Interface"/>
        <rdfs:subPropertyOf rdf:resource="#hasSuperType"/>
        <owl:inverseOf rdf:resource="#isImplementedBy"/>
    </owl:ObjectProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#invokesMethod -->

    <owl:ObjectProperty rdf:about="#invokesMethod">
        <rdfs:comment
            >A method or constructor can call a method of another class or of an instance of another class. It can also call methods of the same class or of instances of the same class. The inverse property is isInvokedByMethod.</rdfs:comment>
        <todo
            >think about who invokes a Constructor</todo>
        <rdfs:range rdf:resource="#Method"/>
        <owl:inverseOf rdf:resource="#isInvokedByMethod"/>
        <rdfs:domain>
            <owl:Class>
                <owl:unionOf rdf:parseType="Collection">
                    <rdf:Description rdf:about="#Constructor"/>
                    <rdf:Description rdf:about="#Method"/>
                </owl:unionOf>
            </owl:Class>
        </rdfs:domain>
    </owl:ObjectProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#isAccessedByMethod -->

    <owl:ObjectProperty rdf:about="#isAccessedByMethod">
        <rdfs:comment
            >A field can be accessed by a method. The inverse property is accessesField.</rdfs:comment>
        <rdfs:domain rdf:resource="#Field"/>
        <rdfs:range>
            <owl:Class>
                <owl:unionOf rdf:parseType="Collection">
                    <rdf:Description rdf:about="#Constructor"/>
                    <rdf:Description rdf:about="#Method"/>
                </owl:unionOf>
            </owl:Class>
        </rdfs:range>
    </owl:ObjectProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#isDatatypeOf -->

    <owl:ObjectProperty rdf:about="#isDatatypeOf">
        <rdfs:comment
            >A variable in Java needs to be declared to be of a particular type. The inverse property is hasDatatype.</rdfs:comment>
        <rdfs:domain rdf:resource="#Datatype"/>
        <rdfs:range rdf:resource="#Variable"/>
    </owl:ObjectProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#isDeclaredConstructorOf -->

    <owl:ObjectProperty rdf:about="#isDeclaredConstructorOf">
        <rdf:type rdf:resource="&owl;FunctionalProperty"/>
        <rdfs:comment
            >A constructor is declared in a class or enumeration type. The inverse property is declaresConstructor.</rdfs:comment>
        <rdfs:domain rdf:resource="#Constructor"/>
        <rdfs:range>
            <owl:Class>
                <owl:unionOf rdf:parseType="Collection">
                    <rdf:Description rdf:about="#Class"/>
                    <rdf:Description rdf:about="#EnumerationType"/>
                </owl:unionOf>
            </owl:Class>
        </rdfs:range>
    </owl:ObjectProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#isDeclaredFieldOf -->

    <owl:ObjectProperty rdf:about="#isDeclaredFieldOf">
        <rdf:type rdf:resource="&owl;FunctionalProperty"/>
        <rdfs:comment
            >A field is declared in a class or interface. The inverse property is declares Field.</rdfs:comment>
        <rdfs:range rdf:resource="#ComplexType"/>
        <rdfs:domain rdf:resource="#Field"/>
    </owl:ObjectProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#isDeclaredInnerComplexTypeOf -->

    <owl:ObjectProperty rdf:about="#isDeclaredInnerComplexTypeOf">
        <rdfs:comment
            >A complex type can be a top-level type or be declared within a class or interface. The inverse property is declaresInnerComplexType.</rdfs:comment>
        <rdfs:range rdf:resource="#ComplexType"/>
        <rdfs:domain rdf:resource="#ComplexType"/>
    </owl:ObjectProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#isDeclaredMethodOf -->

    <owl:ObjectProperty rdf:about="#isDeclaredMethodOf">
        <rdf:type rdf:resource="&owl;FunctionalProperty"/>
        <rdfs:comment
            >A method is declared in a complex type. The inverse property is declaresMethod.</rdfs:comment>
        <rdfs:range rdf:resource="#ComplexType"/>
        <rdfs:domain rdf:resource="#Method"/>
    </owl:ObjectProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#isImplementedBy -->

    <owl:ObjectProperty rdf:about="#isImplementedBy">
        <rdfs:comment
            >An interface can be implemented by a class. The inverse property is implementsInterface.</rdfs:comment>
        <rdfs:range rdf:resource="#Class"/>
        <rdfs:domain rdf:resource="#Interface"/>
        <rdfs:subPropertyOf rdf:resource="#hasSubType"/>
    </owl:ObjectProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#isInvokedByMethod -->

    <owl:ObjectProperty rdf:about="#isInvokedByMethod">
        <rdfs:comment
            >A method can be invoked by an constructor or method. The inverse property is invokesMethod.</rdfs:comment>
        <rdfs:domain rdf:resource="#Method"/>
        <rdfs:range>
            <owl:Class>
                <owl:unionOf rdf:parseType="Collection">
                    <rdf:Description rdf:about="#Constructor"/>
                    <rdf:Description rdf:about="#Method"/>
                </owl:unionOf>
            </owl:Class>
        </rdfs:range>
    </owl:ObjectProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#isPackageMemberOf -->

    <owl:ObjectProperty rdf:about="#isPackageMemberOf">
        <rdfs:comment
            >ComplexTypes are members of a package.</rdfs:comment>
        <rdfs:domain rdf:resource="#ComplexType"/>
        <rdfs:range rdf:resource="#Package"/>
    </owl:ObjectProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#isParameterOf -->

    <owl:ObjectProperty rdf:about="#isParameterOf">
        <rdfs:comment
            >A parameter can be passed to a method. The inverse property is hasParameter.</rdfs:comment>
        <rdfs:domain rdf:resource="#Parameter"/>
        <rdfs:range>
            <owl:Class>
                <owl:unionOf rdf:parseType="Collection">
                    <rdf:Description rdf:about="#Constructor"/>
                    <rdf:Description rdf:about="#Method"/>
                </owl:unionOf>
            </owl:Class>
        </rdfs:range>
    </owl:ObjectProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#isReturnTypeOf -->

    <owl:ObjectProperty rdf:about="#isReturnTypeOf">
        <rdfs:comment
            >A value of a certain type can be returned by a method. The inverse property is hasReturnType.</rdfs:comment>
        <rdfs:domain rdf:resource="#Datatype"/>
        <rdfs:range rdf:resource="#Method"/>
    </owl:ObjectProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#isThrownBy -->

    <owl:ObjectProperty rdf:about="#isThrownBy">
        <rdfs:comment
            >Exceptions can be thrown by methods or constructors if abnormal program flow occurs. The inverse property is throwsException.</rdfs:comment>
        <rdfs:domain rdf:resource="#Exception"/>
        <rdfs:range>
            <owl:Class>
                <owl:unionOf rdf:parseType="Collection">
                    <rdf:Description rdf:about="#Constructor"/>
                    <rdf:Description rdf:about="#Method"/>
                </owl:unionOf>
            </owl:Class>
        </rdfs:range>
    </owl:ObjectProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#throwsException -->

    <owl:ObjectProperty rdf:about="#throwsException">
        <rdfs:comment
            >A method or constructor can throw an exception in case of abnormal program flow. The inverse property is isThrownBy.</rdfs:comment>
        <rdfs:range rdf:resource="#Exception"/>
        <owl:inverseOf rdf:resource="#isThrownBy"/>
        <rdfs:domain>
            <owl:Class>
                <owl:unionOf rdf:parseType="Collection">
                    <rdf:Description rdf:about="#Constructor"/>
                    <rdf:Description rdf:about="#Method"/>
                </owl:unionOf>
            </owl:Class>
        </rdfs:domain>
    </owl:ObjectProperty>
    


    <!-- 
    ///////////////////////////////////////////////////////////////////////////////////////
    //
    // Data properties
    //
    ///////////////////////////////////////////////////////////////////////////////////////
     -->

    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#hasIdentifier -->

    <owl:DatatypeProperty rdf:about="#hasIdentifier">
        <rdf:type rdf:resource="&owl;FunctionalProperty"/>
        <todo
            >Maybe change property name to &quot;hasName&quot;</todo>
        <rdfs:comment
            >All Java entities can have an identifier, e.g., a class-, variable, or method name.</rdfs:comment>
        <rdfs:domain rdf:resource="#JavaEntity"/>
        <rdfs:range rdf:resource="&xsd;string"/>
    </owl:DatatypeProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#hasJavaDoc -->

    <owl:DatatypeProperty rdf:about="#hasJavaDoc">
        <rdfs:comment
            >Source code documentation that follows the &quot;doc comments&quot; format used by the Javadoc tool.</rdfs:comment>
        <rdfs:range rdf:resource="&xsd;string"/>
        <rdfs:domain>
            <owl:Class>
                <owl:unionOf rdf:parseType="Collection">
                    <rdf:Description rdf:about="#ComplexType"/>
                    <rdf:Description rdf:about="#Constructor"/>
                    <rdf:Description rdf:about="#Field"/>
                    <rdf:Description rdf:about="#Method"/>
                    <rdf:Description rdf:about="#Package"/>
                </owl:unionOf>
            </owl:Class>
        </rdfs:domain>
    </owl:DatatypeProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#hasLength -->

    <owl:DatatypeProperty rdf:about="#hasLength">
        <rdfs:comment
            >The lexical length of an entity within a source file.</rdfs:comment>
        <rdfs:range rdf:resource="&xsd;int"/>
        <rdfs:domain>
            <owl:Class>
                <owl:unionOf rdf:parseType="Collection">
                    <rdf:Description rdf:about="#ComplexType"/>
                    <rdf:Description rdf:about="#Constructor"/>
                    <rdf:Description rdf:about="#Method"/>
                    <rdf:Description rdf:about="#Variable"/>
                </owl:unionOf>
            </owl:Class>
        </rdfs:domain>
    </owl:DatatypeProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#hasPosition -->

    <owl:DatatypeProperty rdf:about="#hasPosition">
        <rdfs:comment
            >The ordering of the parameters of a method is crucial, e.g., for method overloading. This property allows to preserve that information.</rdfs:comment>
        <rdfs:domain rdf:resource="#Parameter"/>
        <rdfs:range rdf:resource="&xsd;nonNegativeInteger"/>
    </owl:DatatypeProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#isAbstract -->

    <owl:DatatypeProperty rdf:about="#isAbstract">
        <rdf:type rdf:resource="&owl;FunctionalProperty"/>
        <rdfs:comment
            >Classes and methods can be declared abstract. If a class is abstract, it cannot have any instances. However, it can be extended by a non-abstract subclass. If a method is declared abstract then it cannot have a body. Instead, an implementation needs to be provided by a subclass (or the subclass needs to be abstract itself).

Annotations and interfaces are implicitly abstract and, accordingly, their methods too.</rdfs:comment>
        <rdfs:range rdf:resource="&xsd;boolean"/>
        <rdfs:domain>
            <owl:Class>
                <owl:unionOf rdf:parseType="Collection">
                    <rdf:Description rdf:about="#AnnotationType"/>
                    <rdf:Description rdf:about="#Class"/>
                    <rdf:Description rdf:about="#Interface"/>
                    <rdf:Description rdf:about="#Method"/>
                </owl:unionOf>
            </owl:Class>
        </rdfs:domain>
    </owl:DatatypeProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#isConstant -->

    <owl:DatatypeProperty rdf:about="#isConstant">
        <rdfs:comment
            >A variable can be declared to be constant by using the keyword &#39;final&#39;. In this case, it is not possible to change its value after initialisation.</rdfs:comment>
        <rdfs:domain rdf:resource="#Variable"/>
        <rdfs:range rdf:resource="&xsd;boolean"/>
    </owl:DatatypeProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#isStatic -->

    <owl:DatatypeProperty rdf:about="#isStatic">
        <rdfs:comment
            >Fields and Methods can be declared as static. They will then belong to the class rather than to the instance.</rdfs:comment>
        <rdfs:range rdf:resource="&xsd;boolean"/>
        <rdfs:domain>
            <owl:Class>
                <owl:unionOf rdf:parseType="Collection">
                    <rdf:Description rdf:about="#Field"/>
                    <rdf:Description rdf:about="#Method"/>
                </owl:unionOf>
            </owl:Class>
        </rdfs:domain>
    </owl:DatatypeProperty>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#startsAt -->

    <owl:DatatypeProperty rdf:about="#startsAt">
        <rdfs:comment
            >The offset of the entity&#39;s declaration within a source file.</rdfs:comment>
        <rdfs:range rdf:resource="&xsd;int"/>
        <rdfs:domain>
            <owl:Class>
                <owl:unionOf rdf:parseType="Collection">
                    <rdf:Description rdf:about="#ComplexType"/>
                    <rdf:Description rdf:about="#Constructor"/>
                    <rdf:Description rdf:about="#Method"/>
                    <rdf:Description rdf:about="#Variable"/>
                </owl:unionOf>
            </owl:Class>
        </rdfs:domain>
    </owl:DatatypeProperty>
    


    <!-- 
    ///////////////////////////////////////////////////////////////////////////////////////
    //
    // Classes
    //
    ///////////////////////////////////////////////////////////////////////////////////////
     -->

    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#AccessModifier -->

    <owl:Class rdf:about="#AccessModifier">
        <rdfs:comment
            >The Class AccessModifier provides an individual for all possible Java access modifiers.

A method or instance variable can only be declared one of public, protected, and private. A method or instance variable declared without any of these modifiers is considered &quot;package-friendly&quot; (default) and is visible to and, in the case of variables, modifiable by any object in the package.</rdfs:comment>
    </owl:Class>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#AnnotationType -->

    <owl:Class rdf:about="#AnnotationType">
        <rdfs:subClassOf rdf:resource="#ComplexType"/>
        <rdfs:comment
            >Annotations are a mechanism for associating a meta-tag with program elements and allowing the Java compiler or the VM to derive program behaviors from these annotated elements or to generate interdependent codes when necessary.</rdfs:comment>
    </owl:Class>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#Class -->

    <owl:Class rdf:about="#Class">
        <rdfs:subClassOf rdf:resource="#ComplexType"/>
        <todo
            >Add isAbstract flag?

Visibility modifiers?</todo>
        <rdfs:comment
            >A class is a programming language construct that is used as a blueprint to create objects. This blueprint describes the state and behavior that the created objects all share. An object created by a class is an instance of the class.</rdfs:comment>
    </owl:Class>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#ComplexType -->

    <owl:Class rdf:about="#ComplexType">
        <rdfs:subClassOf rdf:resource="#Datatype"/>
        <owl:disjointWith rdf:resource="#PrimitiveType"/>
        <rdfs:comment
            >Complex (aka. compound/composite)  types are constructed recursively, starting from primitive types. In addition, they can define fields and methods.</rdfs:comment>
    </owl:Class>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#Constructor -->

    <owl:Class rdf:about="#Constructor">
        <rdfs:subClassOf rdf:resource="#JavaEntity"/>
        <rdfs:comment
            >Constructors are used to create an instance of a Java class. 

Basically, a constructor is a special method. However, Java Interfaces and Annotations cannot have constructors. Further a constructor&#39;s signature differs from a method&#39;s one. Constructor signatures can only have access modifiers, i.e., they cannot be &#39;abstract&#39;, &#39;final&#39;, &#39;native&#39;, &#39;static&#39;, or synchronized. They cannot return anything and they need to have the same identifier as the class they&#39;re defined in.

Because of this differences, we did not model Constructor as a subclass of Method.</rdfs:comment>
    </owl:Class>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#Datatype -->

    <owl:Class rdf:about="#Datatype">
        <rdfs:subClassOf rdf:resource="#JavaEntity"/>
        <rdfs:comment
            >A datatype describes the representation, interpretation, and structure of values or objects stored in computer memory.</rdfs:comment>
    </owl:Class>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#EnumerationType -->

    <owl:Class rdf:about="#EnumerationType">
        <rdfs:subClassOf rdf:resource="#ComplexType"/>
        <todo
            >should probably be a subclass of &#39;Class&#39;. It HAS actually a superclass -&gt; java.lang.Enum.</todo>
        <rdfs:comment
            >An enum type is a type whose fields consist of a fixed set of constants. Common examples include compass directions (values of NORTH, SOUTH, EAST, and WEST) and the days of the week. They are defined in Java using the keyword &#39;enum&#39;. Their class body can include methods and other fields. 

Enums implicitly extend java.lang.Enum. Since Java does not support multiple inheritance, an enum cannot extend anything else.</rdfs:comment>
    </owl:Class>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#Exception -->

    <owl:Class rdf:about="#Exception">
        <rdfs:subClassOf rdf:resource="#Class"/>
        <rdfs:comment
            >An exception is a programming language construct designed to handle the occurrence of special conditions that change the normal flow of execution.

In Java, user-defined exceptions are subclasses of java.lang.Exception (statically checked, meaning that callers of methods throwing the exception need to catch them or explicitely declare that they (re-)throw it) or java.lang.RuntimeException (unchecked).</rdfs:comment>
    </owl:Class>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#Field -->

    <owl:Class rdf:about="#Field">
        <rdfs:subClassOf rdf:resource="#Variable"/>
        <rdfs:comment
            >Fields are either class or instance variables. Class variables are declared with the keyword static.

When a number of objects are created from the same class blueprint, they each have their own distinct copies of instance variables. Two distinct objects of person might for example have different values for their names.

Class variables are common to all objects: Every instance of the class shares a class variable, which is in one fixed location in memory. Any object can change the value of a class variable, but class variables can also be manipulated without creating an instance of the class.</rdfs:comment>
    </owl:Class>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#Interface -->

    <owl:Class rdf:about="#Interface">
        <rdfs:subClassOf rdf:resource="#ComplexType"/>
        <rdfs:comment
            >Interfaces form a contract between a class and the outside world, and this contract is enforced at build time by the compiler. If a class claims to implement an interface, all methods defined by that interface must appear in its source code before the class will successfully compile.

Interfaces are declared using the interface keyword, and may only contain method signatures and constant declarations (variable declarations which are declared to be both static and final). An interface may never contain method bodies.

As interfaces are implicitly abstract, they cannot be directly instantiated except when instantiated by a class which implements the said interface.

Interfaces simulate multiple inheritance - a mechanism that Java otherwise would not provide. Interfaces can extend other interfaces but they cannot implement them.</rdfs:comment>
    </owl:Class>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#JavaEntity -->

    <owl:Class rdf:about="#JavaEntity">
        <rdfs:comment
            >Common superclass for all entities that are modelled in the SEON Java ontology.</rdfs:comment>
    </owl:Class>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#Method -->

    <owl:Class rdf:about="#Method">
        <rdfs:subClassOf rdf:resource="#JavaEntity"/>
        <rdfs:comment
            >A method is a subroutine that is exclusively associated either with a class (in which case it is called a class method or a static method) or with an object (in which case it is an instance method). Like a subroutine in procedural programming languages, a method usually consists of a sequence of programming statements to perform an action, a set of input parameters to customize those actions, and possibly an output value (called the return value) of some kind. Methods provide a mechanism for accessing and manipulating the encapsulated data stored in an object.</rdfs:comment>
    </owl:Class>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#Package -->

    <owl:Class rdf:about="#Package">
        <rdfs:subClassOf rdf:resource="#JavaEntity"/>
        <rdfs:comment
            >Packages are a mechanism for organizing Java classes into namespaces; they provide a unique namespace for the types it contains.

Packages are usually defined using a hierarchical naming pattern, with levels in the hierarchy separated by periods (.) (pronounced &quot;dot&quot;). Although packages lower in the naming hierarchy are often referred to as &quot;subpackages&quot; of the corresponding packages higher in the hierarchy, there is no semantic relationship between packages. Therefore, we cannot make statements, like &quot;Package a contains Package a.b.&quot;</rdfs:comment>
    </owl:Class>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#Parameter -->

    <owl:Class rdf:about="#Parameter">
        <rdfs:subClassOf rdf:resource="#Variable"/>
        <rdfs:comment
            >A parameter is a special kind of variable that refers to data that a method or constructor receives to operate on. A method or constructor can expect zero, one, or several parameters. Primitive types are passed by value, whereas complex types are passed by reference (value).</rdfs:comment>
    </owl:Class>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#PrimitiveType -->

    <owl:Class rdf:about="#PrimitiveType">
        <rdfs:subClassOf rdf:resource="#Datatype"/>
        <rdfs:comment
            >A primitive type is a basic building block for complex types. It has a single value (e.g., an integer, boolean, byte, etc.), but it does not have any behaviour (aka. methods). Further, they are passed by value, not by reference (value) as parameter to methods.

It is sometimes also called built-in type in Java. This term is, however, inadequate since the language also provides &quot;built-in&quot; support for e.g., Strings, which - in conflict with our definition of a primitive type - do have behaviour.</rdfs:comment>
    </owl:Class>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#Variable -->

    <owl:Class rdf:about="#Variable">
        <rdfs:subClassOf rdf:resource="#JavaEntity"/>
        <rdfs:comment
            >A variable is an identifier (letter, word, or phrase) that is linked to a value of a certain type. 

A variable name is made from the following characters, starting with a letter:

* Letters: a-z, A-Z, and other alphabetic characters from other languages.
* Digits: 0-9
* Special: _ (underscore)

Names cannot be the same as a Java keyword (eg, import, if, class, etc.).</rdfs:comment>
        <todo
            >add isConstant flag</todo>
    </owl:Class>
    


    <!-- http://www.w3.org/2002/07/owl#Thing -->

    <owl:Class rdf:about="&owl;Thing"/>
    


    <!-- 
    ///////////////////////////////////////////////////////////////////////////////////////
    //
    // Individuals
    //
    ///////////////////////////////////////////////////////////////////////////////////////
     -->

    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#default -->

    <owl:Thing rdf:about="#default">
        <rdf:type rdf:resource="#AccessModifier"/>
    </owl:Thing>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#private -->

    <AccessModifier rdf:about="#private">
        <rdf:type rdf:resource="&owl;Thing"/>
    </AccessModifier>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#protected -->

    <owl:Thing rdf:about="#protected">
        <rdf:type rdf:resource="#AccessModifier"/>
    </owl:Thing>
    


    <!-- http://evolizer.org/ontologies/seon/2009/06/java.owl#public -->

    <owl:Thing rdf:about="#public">
        <rdf:type rdf:resource="#AccessModifier"/>
    </owl:Thing>
    


    <!-- 
    ///////////////////////////////////////////////////////////////////////////////////////
    //
    // General axioms
    //
    ///////////////////////////////////////////////////////////////////////////////////////
     -->

    <rdf:Description>
        <rdf:type rdf:resource="&owl;AllDisjointClasses"/>
        <owl:members rdf:parseType="Collection">
            <rdf:Description rdf:about="#AnnotationType"/>
            <rdf:Description rdf:about="#Class"/>
            <rdf:Description rdf:about="#EnumerationType"/>
            <rdf:Description rdf:about="#Interface"/>
        </owl:members>
    </rdf:Description>
    <rdf:Description>
        <rdf:type rdf:resource="&owl;AllDisjointClasses"/>
        <owl:members rdf:parseType="Collection">
            <rdf:Description rdf:about="#Datatype"/>
            <rdf:Description rdf:about="#Method"/>
            <rdf:Description rdf:about="#Package"/>
            <rdf:Description rdf:about="#Variable"/>
        </owl:members>
    </rdf:Description>
</rdf:RDF>



<!-- Generated by the OWL API (version 2.2.1.1138) http://owlapi.sourceforge.net -->

